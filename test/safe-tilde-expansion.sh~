#!/bin/bash

#This function safely expands the provided path

#accepts the string to be intyerpreted as a file path and perform an expansion on
#prints empty if for some reason expansion fails

safe_expand_file_path(){
    if [ -z "$1" ]; then
	printf ""
	return 0
    fi

    printf "\nReceived value is %s\n" "$1"
    local quotes=0
    local char=
    local word=
    local index=0
    local space=0
    local unquoted_slash=0
    local unquoted_tilde=0

    #this is done to prevent read ignoring leading and trailing IFS characters
    local orig_IFS="$IFS"
    IFS=
    #identify the tilde prefix if present
    while read -r -N 1 char; do
	#printf "Char is %s\n" "$char"
	if [ "$char" == "~" ]; then
	    if [ "$quotes" -eq 0 ]; then
		unquoted_tilde=1;
	    fi
	elif [ "$char" == "\"" ]; then
	    if [ "$quotes" -eq 0 ]; then
		quotes=1;
	    else
		quotes=0;
	    fi
	elif [ "$char" == " " ]; then
	    space=1
	elif [ "$char" == "/" ]; then
	    if [ "$quotes" -eq 0 ]; then
		unquoted_slash=1
	    fi
	fi
	word="$word""$char"
	if [ "$space" -eq 1 ] || [ "$unquoted_slash" -eq 1 ]; then
	    break;
	fi
    done < <(printf "%s" "$1")

    #restore the IFS
    IFS="$orig_IFS"    
    printf "Variables are Space:%s UnquotedSlash:%s UnquotedTilde:%s\n" "$space" "$unquoted_slash" "$unquoted_tilde"
    if [ "$space" -eq 0 ] && [ "$unquoted_tilde" -eq 1 ]; then
	printf "Possilbe tilde-prefix is %s\n" "$word"
    fi
}
